<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eggplant Functional: A Beginner's Guide</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #f4f4f4;
            color: #333;
        }
        header {
            background: #35424a;
            color: #ffffff;
            padding: 20px 0;
            text-align: center;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
        }
        section {
            background: #ffffff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3, h4 {
            color: #35424a;
        }
        p {
            margin-bottom: 10px;
        }
        ul {
            margin-left: 20px;
        }
        code {
            background: #f4f4f4;
            border-left: 4px solid #35424a;
            color: #333;
            display: block;
            padding: 10px;
            margin: 20px 0;
            white-space: pre-wrap;
        }
        footer {
            background: #35424a;
            color: #ffffff;
            text-align: center;
            padding: 10px 0;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Eggplant Functional: A Beginner's Guide</h1>
        </div>
    </header>

    <div class="container">
        <section>
            <h2>Welcome to Eggplant Functional!</h2>
            <p>This guide is designed for those who have just started learning Eggplant and want to understand the most important features and functionalities. Over the past week, you've been getting familiar with the tool, and this documentation will consolidate what you've learned so far. It will focus on key areas you need to master as you continue your journey with Eggplant. </p>
            <p>Before you start reading the documentation I’ve begun to prepare, please note that this is not a completely reliable resource yet, at least for now. I’m still in the learning phase, and this documentation reflects what I’ve learned so far, without extensive filtering. I’ve tried to compile the most refined information I’ve gathered. There may be mistakes, so if you spot any, please let me know. More importantly, please don’t hesitate to contribute to this documentation. If you notice anything we’ve missed as a team or something I’ve forgotten to include, feel free to reach out, and we can work on improving this platform together.
            ...
            <cite>- Hakan Yorgancı, Sr. Consultant</cite>
            </p>
        </section>

        <section>
            <h2>1. Understanding Eggplant Functional: The Basics</h2>
            <p>Eggplant Functional is a GUI test automation tool that uses image-based testing to interact with the system under test (SUT). Unlike traditional testing tools that rely on code or APIs, Eggplant works by recognizing elements on the screen using images, text (via OCR), and coordinates. Here are the core components:</p>
            <ul>
                <li><strong>SUT (System Under Test):</strong> The application or system you are testing. Eggplant interacts with the SUT through a remote connection.</li>
                <li><strong>Scripts:</strong> Test scripts written in the SenseTalk language to automate interactions with the SUT.</li>
                <li><strong>Images:</strong> Key elements on the SUT’s interface that Eggplant recognizes and interacts with during testing.</li>
                <li><strong>OCR (Optical Character Recognition):</strong> Used to recognize and validate text within the SUT.</li>
            </ul>
        </section>

        <section>
            <h2>2. Setting Up Your First Test Script</h2>
            <h3>2.1 Connecting to the SUT</h3>
            <p>Before you can automate any tests, you need to connect to the SUT:</p>
            <code>Connect "192.168.1.100" -- IP address of the SUT</code>

            <h3>2.2 Creating a Basic Script</h3>
            <p>Let’s start with a simple script that opens an application and performs a basic operation, like logging in:</p>
            <code>
                Click "LoginButton.png" -- Click the login button<br>
                WaitFor "UsernameField.png" -- Wait for the username field to appear<br>
                TypeText "testuser" -- Type the username<br>
                TypeText Tab -- Move to the password field<br>
                TypeText "password123" -- Type the password<br>
                Click "SubmitButton.png" -- Click the submit button
            </code>

            <h3>Key Points:</h3>
            <ul>
                <li><strong>Click:</strong> Used to click on an image (button, field, etc.).</li>
                <li><strong>WaitFor:</strong> Waits until the specified image appears on the screen.</li>
                <li><strong>TypeText:</strong> Simulates typing text into a field.</li>
            </ul>
        </section>

        <section>
            <h2>3. Image-Based Testing</h2>
            <p>Image recognition is the cornerstone of Eggplant testing. Each element on the SUT’s interface that you want to interact with must be captured as an image.</p>

            <h3>3.1 Capturing Images</h3>
            <p>To capture images:</p>
            <ul>
                <li>Open the Capture Mode.</li>
                <li>Hover over the element on the SUT.</li>
                <li>Press the Capture button.</li>
            </ul>

            <h3>3.2 Using Images in Scripts</h3>
            <p>After capturing images, use them in your scripts:</p>
            <code>
                Click "SearchIcon.png"<br>
                WaitFor "SearchField.png"<br>
                TypeText "Test Automation"<br>
                Click "SearchButton.png"
            </code>

            <h3>Tips:</h3>
            <ul>
                <li>Keep your image captures clean and consistent.</li>
                <li>If possible, capture images with distinct shapes or colors to improve recognition accuracy.</li>
            </ul>
        </section>

        <section>
            <h2>4. OCR (Optical Character Recognition)</h2>
            <p>OCR allows you to recognize and interact with text in your application, which is particularly useful when the text might change slightly or when dealing with dynamic content.</p>

            <h3>4.1 Basic OCR Usage</h3>
            <p>Here’s how to click on a button by recognizing its label text:</p>
            <code>Click (Text:"Login", OcrConfidence:85) -- Clicks on a button labeled "Login"</code>

            <h3>4.2 Tuning OCR Settings</h3>
            <p>Sometimes, you might need to fine-tune the OCR settings to improve accuracy:</p>
            <code>
                Set the OcrSearchRectangle to (100,100,600,400) -- Defines the area to search for text<br>
                Set the OcrLanguage to "English" -- Sets the OCR language<br>
                Click (Text:"Submit", OcrConfidence:90)
            </code>

            <h3>Key Points:</h3>
            <ul>
                <li><strong>OcrSearchRectangle:</strong> Limits the area where OCR looks for text.</li>
                <li><strong>OcrConfidence:</strong> Sets the confidence level required for text recognition.</li>
            </ul>
        </section>

        <section>
            <h2>5. Handling Dynamic Content and Resilience</h2>
            <h3>5.1 Using Variables for Dynamic Data</h3>
            <p>When working with data that changes, such as user input or dynamic text, you can use variables:</p>
            <code>
                put "newuser" into username<br>
                put "mypassword" into password<br>
                TypeText username<br>
                TypeText Tab<br>
                TypeText password
            </code>

            <h3>5.2 Implementing Conditional Logic</h3>
            <p>Sometimes, the script’s flow needs to change based on what’s on the screen:</p>
            <code>
                if ImageFound("ErrorMessage.png") then<br>
                &nbsp;&nbsp;&nbsp;&nbsp;logError "An error occurred during login."<br>
                else<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Click "DashboardIcon.png"<br>
                end if
            </code>

            <h3>Key Points:</h3>
            <ul>
                <li><strong>ImageFound:</strong> Checks if an image exists on the screen.</li>
                <li><strong>Conditional Logic:</strong> Directs the script based on conditions.</li>
            </ul>
        </section>
    </div>
        <div class="container">
        <section>
            <h2>6. Best Practices for Maintainability</h2>
            <h3>6.1 Modularizing Your Scripts</h3>
            <p>Break your scripts into smaller, reusable functions:</p>


        <code>
            to Login(username, password)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "LoginButton.png"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText username<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText Tab<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText password<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "SubmitButton.png"<br>
            end Login
        </code>
        <p>-- Call the function</p>
        <code>Login("testuser", "password123")</code>

        <h3>6.2 Centralizing Data</h3>
        <p>Keep your data separate from your scripts:</p>
        <code>
            {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;"username": "testuser",<br>
            &nbsp;&nbsp;&nbsp;&nbsp;"password": "password123"<br>
            }<br>
            put file "UserData.json" into jsonData<br>
            put jsonData as json into data<br>
            Login(data.username, data.password)
        </code>

        <h3>Key Points:</h3>
        <ul>
            <li><strong>Modular Functions:</strong> Makes your scripts more reusable and easier to maintain.</li>
            <li><strong>Centralized Data:</strong> Simplifies updates when test data changes.</li>
        </ul>
    </section>

    <section>
        <h2>7. Troubleshooting and Debugging</h2>
        <h3>7.1 Logging</h3>
        <p>Always log key actions and results to help with debugging:</p>
        <code>
            log "Starting login process"<br>
            Click "LoginButton.png"<br>
            log "Login button clicked"
        </code>

        <h3>7.2 Try-Catch Blocks</h3>
        <p>Handle errors gracefully to prevent script failures:</p>
        <code>
            try<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "NonExistentButton.png"<br>
            catch<br>
            &nbsp;&nbsp;&nbsp;&nbsp;logError "Failed to find the button"<br>
            end try
        </code>

        <h3>Key Points:</h3>
        <ul>
            <li><strong>Logging:</strong> Helps trace what happened during a test run.</li>
            <li><strong>Error Handling:</strong> Prevents entire script failures by catching and managing errors.</li>
        </ul>
    </section>

    <section>
        <h2>8. Code Reusability in Eggplant Functional</h2>
        <p>Code reusability is a critical concept in software development and test automation that focuses on writing code in a way that it can be reused across multiple scripts, test cases, or even different projects. In Eggplant Functional, reusability helps you avoid duplication, reduce maintenance effort, and create a more organized and efficient test suite. Here’s how you can achieve and maximize code reusability in Eggplant Functional:</p>

        <h3>8.1 Creating Reusable Functions</h3>
        <p>Reusable functions allow you to encapsulate frequently used actions or sequences of actions into a single function. This function can then be called whenever needed, rather than rewriting the same code in multiple places.</p>
        <p>Example: Let’s say you have a login process that you need to perform in multiple test cases. Instead of writing the login steps repeatedly in each script, you can create a reusable function:</p>
        <code>
            to Login(username, password)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "LoginButton.png"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText username<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText Tab<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText password<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "SubmitButton.png"<br>
            end Login
        </code>
        <p>You can then call this Login function in any script where you need to perform a login:</p>
        <code>Login("testuser", "password123")</code>

        <h3>Benefits:</h3>
        <ul>
            <li><strong>Reduced Duplication:</strong> You avoid writing the same login steps in every script.</li>
            <li><strong>Simplified Maintenance:</strong> If the login process changes (e.g., the button image changes), you only need to update the Login function, not every test script.</li>
        </ul>

        <h3>8.2 Using Parameters in Functions</h3>
        <p>Functions can be made even more flexible by using parameters. This allows the same function to be used in different contexts with different data.</p>
        <p>Example: A function to search for different items on a website:</p>
        <code>
            to SearchFor(item)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "SearchIcon.png"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;WaitFor "SearchField.png"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText item<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "SearchButton.png"<br>
            end SearchFor
        </code>
        <p>You can call this function with different parameters to search for different items:</p>
        <code>
            SearchFor("Eggplant")<br>
            SearchFor("Test Automation")
        </code>

        <h3>Benefits:</h3>
        <ul>
            <li><strong>Flexibility:</strong> One function can handle a variety of inputs, making it more versatile.</li>
            <li><strong>Scalability:</strong> As your test cases grow, you can easily reuse the same functions with different data.</li>
        </ul>
    </section>

    <section>
        <h3>8.3 Modularizing Test Scripts</h3>
        <p>Breaking down your test scripts into smaller, modular components is another way to enhance reusability. Instead of writing one large script, divide it into smaller, logical sections that can be reused independently.</p>
        <p>Example: Consider a test for a shopping cart application:</p>
        <ul>
            <li>AddItemToCart</li>
            <li>RemoveItemFromCart</li>
            <li>ProceedToCheckout</li>
            <li>ApplyCoupon</li>
        </ul>
        <p>Each of these actions can be encapsulated in its own function:</p>
        <code>
            to AddItemToCart(item)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click item<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "AddToCartButton.png"<br>
            end AddItemToCart<br><br>
            to RemoveItemFromCart(item)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click item<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "RemoveButton.png"<br>
            end RemoveItemFromCart<br><br>
            to ProceedToCheckout()<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "CartIcon.png"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "CheckoutButton.png"<br>
            end ProceedToCheckout<br><br>
            to ApplyCoupon(couponCode)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "CouponField.png"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;TypeText couponCode<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Click "ApplyButton.png"<br>
            end ApplyCoupon
        </code>
        <p>These functions can be combined in different scripts to create various test scenarios:</p>
        <code>
            AddItemToCart("Laptop.png")<br>
            AddItemToCart("Mouse.png")<br>
            ApplyCoupon("DISCOUNT10")<br>
            ProceedToCheckout()
        </code>

        <h3>Benefits:</h3>
        <ul>
            <li>Reuse Across Scenarios: Modular functions can be mixed and matched to create different test scenarios without rewriting code.</li>
            <li>Improved Clarity: Each function performs a specific task, making your scripts easier to read and understand.</li>
        </ul>
    </section>
</div>

    <div class="container">
        <section>
            <h2>9. Data-Driven Testing</h2>
            <p>Data-driven testing is a technique where test scripts are executed with different sets of input data. This approach helps you validate that the application behaves correctly with various data inputs without having to write separate test scripts for each set of data. It significantly enhances test coverage and reduces the effort required to create new tests.</p>

            <h3>9.1 Setting Up Data-Driven Tests</h3>
            <p>In Eggplant Functional, you can use external data sources, such as CSV files, Excel sheets, or JSON files, to drive your tests.</p>
            <p>Example: Suppose you have a login test that needs to be run with different sets of usernames and passwords. Instead of writing separate scripts, you can use a CSV file to provide the data:</p>
            <code>
                username,password<br>
                testuser1,password1<br>
                testuser2,password2<br>
                testuser3,password3
            </code>

        <h3>9.2 Implementing Data-Driven Tests</h3>
        <p>Here’s how you can implement a data-driven test using the CSV file:</p>
        <code>
            set userData to file "UserData.csv" as table<br>
            repeat with each record of userData<br>
            &nbsp;&nbsp;&nbsp;&nbsp;put record's username into username<br>
            &nbsp;&nbsp;&nbsp;&nbsp;put record's password into password<br><br>
            &nbsp;&nbsp;&nbsp;&nbsp;Login(username, password)<br><br>
            &nbsp;&nbsp;&nbsp;&nbsp;if ImageFound("Dashboard.png") then<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log "Login successful for" && username<br>
            &nbsp;&nbsp;&nbsp;&nbsp;else<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logError "Login failed for" && username<br>
            &nbsp;&nbsp;&nbsp;&nbsp;end if<br>
            end repeat
        </code>

        <h3>Benefits:</h3>
        <ul>
            <li>Enhanced Coverage: You can easily test multiple data sets without writing additional scripts.</li>
            <li>Scalability: As new data sets are added, the same test script can handle them without modification.</li>
        </ul>
    </section>

    <section>
        <h2>10. Test Execution and Reporting</h2>
        <p>Automating the execution of your test suite and generating reports are crucial aspects of test automation. Eggplant Functional provides various ways to execute tests and produce reports that help you understand test results and track progress.</p>

        <h3>10.1 Automating Test Execution</h3>
        <p>You can schedule or automate the execution of your test suite using continuous integration (CI) tools such as Jenkins. This ensures that your tests are run regularly, such as after every code change or at specific intervals.</p>
        <p>Example: You can run your test suite from the command line, which can then be integrated into a CI pipeline:</p>
        <code>eggplant --suite "MyTestSuite.suite"</code>
        <p>This command can be scheduled or triggered by your CI tool.</p>

        <h3>10.2 Generating Test Reports</h3>
        <p>Eggplant Functional automatically generates detailed logs and reports for each test run. These reports can be customized and analyzed to track the success rate, identify failures, and monitor the overall health of your application.</p>

        <h3>Key Points:</h3>
        <ul>
            <li>HTML Reports: Eggplant provides HTML reports that are easy to share and review.</li>
            <li>Log Files: Detailed log files contain step-by-step results of the test execution, helping you debug issues.</li>
        </ul>

        <h3>Benefits:</h3>
        <ul>
            <li>Continuous Feedback: Automated execution provides quick feedback on the health of your application.</li>
            <li>Accountability: Reports and logs offer detailed records of test execution, which is useful for auditing and troubleshooting.</li>
        </ul>
    </section>
        
    <section>
        <h2>11. Handling Asynchronous Events</h2>
        <p>Applications often include asynchronous events such as animations, dynamic content loading, or delays in server responses. Handling these events in test scripts is crucial to avoid false failures and ensure that tests are robust.</p>

        <h3>11.1 Using WaitFor and Wait Commands</h3>
        <p>Eggplant Functional offers WaitFor and Wait commands to handle asynchronous events. These commands allow the script to pause until a specific condition is met, ensuring that the script only proceeds when the SUT is ready.</p>
        <p>Example: Suppose you are waiting for a loading spinner to disappear before proceeding:</p>
        <code>
            WaitFor "LoadingSpinner.png" to disappear<br>
            Click "SubmitButton.png"
        </code>
        <p>Or you might need to wait a fixed amount of time before interacting with an element:</p>
        <code>
            Wait 5 seconds<br>
            Click "SubmitButton.png"
        </code>

        <h3>Benefits:</h3>
        <ul>
            <li><strong>Reliability:</strong> Your tests become more reliable by accounting for unpredictable delays or asynchronous events.</li>
            <li><strong>Avoiding False Negatives:</strong> Proper waiting mechanisms prevent scripts from failing due to timing issues, thereby reducing false negatives.</li>
        </ul>
    </section>

    <section>
        <h2>12. Parallel Testing</h2>
        <p>Parallel testing involves running multiple tests at the same time across different environments, browsers, or devices. This technique significantly reduces the total time required to execute your test suite and allows for broader test coverage.</p>

        <h3>12.1 Implementing Parallel Testing</h3>
        <p>Eggplant Functional allows for parallel testing through its integration with CI tools and test management frameworks. You can configure your tests to run on multiple instances of the SUT simultaneously.</p>
        <p>Example: Using Jenkins or another CI tool, you can configure jobs to run your tests in parallel across different SUTs:</p>
        <code>
            eggplant --suite "MyTestSuite.suite" --parallel --sut "SUT1, SUT2, SUT3"
        </code>

        <h3>Benefits:</h3>
        <ul>
            <li><strong>Speed:</strong> Parallel execution significantly reduces the time to run the full test suite.</li>
            <li><strong>Coverage:</strong> Allows you to test across multiple configurations simultaneously, increasing coverage.</li>
        </ul>
    </section>

    <section>
        <h2>13. Continuous Integration and Continuous Testing</h2>
        <p>Integrating Eggplant Functional with continuous integration (CI) tools is essential for ensuring that automated tests are run continuously, providing immediate feedback on new code changes.</p>

        <h3>13.1 Integrating with CI Tools</h3>
        <p>Eggplant Functional can be integrated with popular CI tools like Jenkins, GitLab CI, or TeamCity. This integration enables the automatic execution of test scripts as part of the build process.</p>
        <p>Example: In Jenkins, you can set up a job to run your Eggplant tests every time there’s a code commit:</p>
        <code>
            eggplant --suite "MyTestSuite.suite" --output "TestResults"
        </code>

        <h3>13.2 Benefits of Continuous Testing</h3>
        <ul>
            <li><strong>Immediate Feedback:</strong> Developers get quick feedback on their changes, enabling faster identification and resolution of defects.</li>
            <li><strong>Reduced Risk:</strong> Continuous testing helps catch issues early in the development cycle, reducing the risk of critical bugs in production.</li>
        </ul>

        <h3>Key Points:</h3>
        <ul>
            <li><strong>Scalability:</strong> CI integration scales well with large teams and frequent releases.</li>
            <li><strong>Automation:</strong> Reduces manual testing efforts and improves overall efficiency.</li>
        </ul>
    </section>

    <section>
        <h2>14. Advanced Debugging Techniques</h2>
        <p>When working with complex test automation, advanced debugging techniques become necessary to identify and resolve issues effectively.</p>

        <h3>14.1 Using Breakpoints</h3>
        <p>You can set breakpoints in Eggplant Functional to pause the execution of a script at a specific point. This allows you to inspect variables, review the SUT’s state, and step through the script line by line.</p>
        <p>Example: Adding a breakpoint in your script:</p>
        <code>
            breakpoint<br>
            Click "SubmitButton.png"
        </code>

        <h3>14.2 Analyzing Logs</h3>
        <p>Eggplant generates detailed logs during test execution. Analyzing these logs can help identify where and why a test failed.</p>

        <h3>Key Points:</h3>
        <ul>
            <li><strong>Error Logs:</strong> Review error messages and stack traces to understand failures.</li>
            <li><strong>Execution Flow:</strong> Follow the execution flow in the logs to see where the script diverged from the expected behavior.</li>
        </ul>

        <h3>Benefits:</h3>
        <ul>
            <li><strong>Precision:</strong> Advanced debugging helps you pinpoint the exact cause of failures.</li>
            <li><strong>Efficiency:</strong> Quickly resolving issues allows for more productive testing and development cycles.</li>
        </ul>
    </section>

    <section>
        <h2>15. Best Practices for Test Automation with Eggplant</h2>
        <p>Lastly, adhering to best practices in test automation ensures that your test suite remains maintainable, scalable, and effective.</p>

        <h3>15.1 Keep Tests Independent</h3>
        <p>Each test should be independent and not rely on the outcome of another test. This ensures that a failure in one test doesn’t cause cascading failures in other tests.</p>

        <h3>15.2 Regularly Refactor Test Scripts</h3>
        <p>Regularly review and refactor your test scripts to remove redundancies, improve readability, and optimize performance.</p>

        <h3>15.3 Maintain a Clear Naming Convention</h3>
        <p>Use clear and consistent naming conventions for your scripts, functions, images, and variables. This makes it easier to understand and manage your test suite.</p>
        <p>Example: Prefix function names with the action they perform (e.g., LoginUser, SearchItem).</p>

        <h3>Benefits:</h3>
        <ul>
            <li><strong>Maintainability:</strong> Clear and well-structured tests are easier to maintain and scale.</li>
            <li><strong>Collaboration:</strong> Following best practices makes it easier for team members to collaborate on test automation.</li>
        </ul>
    </section>

    <section>
        <h2>16. Dynamic Test Reporting in Eggplant Functional</h2>
        <p>Eggplant Functional provides robust capabilities for dynamic test reporting. This section covers how to generate automated reports based on test executions, including handling dynamic test case names and Suite Statistics.</p>

        <h3>16.1 Generating Automated CSV Reports</h3>
        <p>To create a CSV report after running multiple test cases in Eggplant Functional, you can incorporate dynamic test result capturing directly into your test scripts.</p>

        <p>Example Script: Automated CSV Reporting</p>
        <code>
        // 1. Initialize CSV File<br>
        put "Test Name, Status, Duration, Comments" into csvHeader<br>
        put csvHeader & return into file "TestResults.csv"<br><br>

        // 2. Define Test Cases<br>
        set testCases to ("Test Case 1", "Test Case 2", "Test Case 3", "Test Case 4")<br><br>

        // 3. Execute Tests and Capture Results<br>
        repeat with each testCase in testCases<br>
        &nbsp;&nbsp;&nbsp;&nbsp;set startTime to now<br>
        &nbsp;&nbsp;&nbsp;&nbsp;try<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Placeholder for actual test steps<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Example: if the test case involves logging in<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if testCase is "Test Case 1" then<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Click "LoginButton.png"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeText "username"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeText tab<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeText "password"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;        Click “SubmitButton.png”
            if ImageFound(“Dashboard.png”) then
                put “Passed” into testStatus
                put “Login successful” into testComments
            else
                put “Failed” into testStatus
                put “Dashboard not found” into testComments
            end if
        end if
    catch
        put “Failed” into testStatus
        put “An error occurred during “ & testCase into testComments
    end try

    &nbsp;&nbsp;&nbsp;&nbsp;set testDuration to the seconds of (now - startTime) & "s"<br><br>

    // 4. Write Results to CSV<br>
    put testCase & "," & testStatus & "," & testDuration & "," & testComments & return after file "TestResults.csv"<br>
    end repeat<br><br>

    // 5. Log the Completion of the Report<br>
    log "CSV report created successfully: TestResults.csv"
    </code>

    <h3>16.2 Handling Dynamic Test Cases and Suite Statistics</h3>
    <p>When working with dynamically generated Suite Statistics, it's essential to process the data correctly and generate accurate reports. Eggplant Functional allows you to read the Suite Statistics file and format the data into a CSV report.</p>

    <p>Example Script: Processing Suite Statistics</p>
    <code>
    // 1. Read Suite Statistics File<br>
    put file "Results/SuiteStatistics.txt" into suiteStats<br><br>

    // 2. Initialize CSV Report<br>
    put "Script, Last Status, Runs, Fails, First Run, Last Run, Avg Time (Success)" into csvHeader<br>
    put csvHeader & return into file "SuiteStatisticsReport.csv"<br><br>

    // 3. Process Each Line in Suite Statistics<br>
    repeat with each line of suiteStats<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if line is not empty then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 1 of line into testCaseName<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 2 of line into lastStatus<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 3 of line into runCount<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 4 of line into failCount<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 5 of line into firstRun<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 6 of line into lastRun<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put word 7 of line into avgTime<br><br>

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4. Write the Processed Data to CSV<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put testCaseName & "," & lastStatus & "," & runCount & "," & failCount & "," & firstRun & "," & lastRun & "," & avgTime & return after file "SuiteStatisticsReport.csv"<br>
    &nbsp;&nbsp;&nbsp;&nbsp;end if<br>
    end repeat<br><br>

    log "Suite Statistics CSV report created successfully."
    </code>
</section>

<section>
    <h2>17. Handling Different Test Case Types Dynamically</h2>
    <p>Different test cases (such as TBA, NADL) might require specific handling in terms of naming conventions, result processing, and reporting. This section explores how to dynamically manage different test types within a single framework.</p>

    <h3>17.1 Dynamic Test Type Handling</h3>
    <p>In complex test suites, you may encounter different types of test cases, each with unique identifiers like "TBA" or "NADL." It is crucial to manage these dynamically to generate accurate reports.</p>

    <p>Example: Handling Different Test Case Types</p>
    <code>
    // 1. Identify and Process Test Type<br>
    repeat with each line of suiteStats<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if line contains "TBA" then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put "TBA_TestResults.csv" into fileName<br>
    &nbsp;&nbsp;&nbsp;&nbsp;else if line contains "NADL" then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put "NADL_TestResults.csv" into fileName<br>
    &nbsp;&nbsp;&nbsp;&nbsp;else<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put "General_TestResults.csv" into fileName<br>
    &nbsp;&nbsp;&nbsp;&nbsp;end if<br><br>

    &nbsp;&nbsp;&nbsp;&nbsp;// Process the line and write to the corresponding file<br>
    &nbsp;&nbsp;&nbsp;&nbsp;put line & return after file fileName<br>
    end repeat
    </code>
</section>

<section>
    <h2>18. Dynamic Naming Conventions for Test Reports</h2>
    <p>Maintaining clear and consistent naming conventions is essential, especially when dealing with dynamically generated reports across various test case types. This section discusses best practices for naming your reports and how to implement these dynamically within your scripts.</p>

    <h3>18.1 Dynamic Naming Based on Test Types and Execution Time</h3>
    <p>Dynamic naming conventions help in keeping reports organized and easily identifiable. This is particularly useful when multiple test cases are run in sequence or across different environments.</p>

    <p>Example: Dynamic Naming Convention</p>
    <code>
    // Dynamic naming based on test type and timestamp<br>
    put "TBA_TestResults_" & the short date & "_" & the time into fileName<br>
    replace all spaces in fileName with "_" // Remove spaces to avoid filename issues<br>
    put ".csv" after fileName<br><br>

    put "Test Name, Status, Duration, Comments" into csvHeader<br>
    put csvHeader & return into file fileName<br><br>

    log "CSV report initialized: " & fileName
    </code>
</section>

<section>
    <h2>19. Best Practices for Automated Reporting</h2>
    <p>Automated reporting is a key aspect of test automation. Proper implementation can greatly enhance the effectiveness and usability of your tests. This section outlines best practices for generating, maintaining, and distributing automated reports in Eggplant Functional.</p>

    <h3>19.1 Consistent Report Formats</h3>
    <p>Ensure that all reports follow a consistent format, making it easier to compare results across different runs or test cases. This includes standardized headers, naming conventions, and data presentation.</p>

    <h3>19.2 Automation of Report Distribution</h3>
    <p>Consider automating the distribution of test reports via email or other communication tools. This can be achieved using external scripts like PowerShell if SMTP access is restricted within Eggplant Functional.</p>

    <p>Example: Automating Report Distribution</p>
    <code>
    # PowerShell script to send an email with the generated CSV report attached<br>
    $EmailFrom = "your_email@example.com"<br>
    $EmailTo = "recipient@example.com"<br>
    $Subject = "Automated Test Results"<br>
    $Body = "Please find the attached test results."<br>
    $SMTPServer = "smtp.yourserver.com"<br>
    $Attachment = "C:\\path\\to\\TestResults.csv"<br><br>

    Send-MailMessage -From $EmailFrom -To $EmailTo -Subject $Subject -Body $Body -SmtpServer $SMTPServer -Attachments $Attachment
    </code>
 </section>
    
</div>

    

<footer>
    <p>Eggplant Functional Guide &copy; 2024. 🍆 Eggplant Team [Deloitte] 🍆 </p>
</footer>

</body>
</html>
